#!/usr/bin/env node

const parseArgs = require('minimist')

const
  logger = require('../lib/helpers/logger')
  log = logger('app:build')
  warn = logger('app:warn', 'red'),
  ensureArgv = require('../lib/helpers/ensure-argv')

const argv = parseArgs(process.argv.slice(2), {
  alias: {
    t: 'theme',
    m: 'mode',
    T: 'target',
    c: 'config-file',
    h: 'help'
  },
  boolean: ['h'],
  string: ['t', 'm', 'T', 'c'],
  default: {
    t: 'mat',
    m: 'spa',
    c: 'quasar.conf.js'
  }
})

if (argv.help) {
  console.log(`
    Description
      Starts the app in development mode (hot-code reloading, error
      reporting, etc)
    Usage
      $ npm run build -- -p <port number>
    Options
      --theme, -t         App theme (default: mat)
      --mode, -m          App mode [spa|pwa|cordova|electron] (default: spa)
      --target, -T        App target [if cordova mode: android|ios; if electron: darwin|win32|linux]
      --config-file, -c   Path to Quasar config file (default: quasar.config.js)
      --help, -h          Displays this message
  `)
  process.exit(0)
}

ensureArgv(argv)

const
  chalk = require('chalk'),
  webpack = require('webpack')

log(`Mode [ ${chalk.red(argv.mode.toUpperCase())} ] with [ ${chalk.red(argv.theme.toUpperCase())} ] theme`)

const
  appPaths = require('../lib/build/app-paths'),
  QuasarConfig = require('../lib/quasar-config'),
  Generator = require('../lib/generator')

const
  quasarConfig = new QuasarConfig({
    filename: argv['config-file'],
    theme: argv.theme,
    mode: argv.mode,
    target: argv.target,
    prod: true
  }),
  generator = new Generator(quasarConfig),
  webpackConfig = quasarConfig.getWebpackConfig(),
  buildConfig = quasarConfig.getBuildConfig(),
  mode = argv.mode.toUpperCase(),
  target = argv.target ? argv.target.toUpperCase() : ''

generator.build()

log(chalk.bold(`Building ${mode}${target ? `/${target}` : ''} with "${argv.theme}" theme...`))
log()

function finalize () {
  if (buildConfig.build.debug) {
    warn(`Built for ${chalk.bold('DEBUG')} - Do NOT deploy this version to production`)
    log()
  }
}

webpack(webpackConfig, (err, stats) => {
  if (err) { throw err }

  const notify = buildConfig.build.useNotifier
    ? require('../lib/helpers/notifier')
    : () => {}

  process.stdout.write(stats.toString({
    colors: true,
    modules: false,
    children: false,
    chunks: false,
    chunkModules: false
  }) + '\n')

  if (stats.hasErrors()) {
    warn()
    warn(chalk.red('[FAIL] Build failed with errors'))
    warn()

    notify({ subtitle: '[FAIL] Build has errors', message: appPaths.appDir  })
    process.exit(1)
  }

  log()
  log(
    `[SUCCESS] ${chalk.bold(mode)} with "${chalk.bold(argv.theme)}" theme in "${chalk.bold(buildConfig.build.distDir)}" folder`
  )
  log()

  if (argv.mode === 'cordova') {
    const cordovaRunner = require('../lib/cordova/cordova-runner')

    cordovaRunner.run(quasarConfig, err => {
      if (err) {
        notify({ subtitle: '[FAIL] Cordova failed to build' })
        return
      }

      warn(`Do NOT use VueRouter's "history" mode as it will break your app!`)
      log()
      finalize()
      notify({ subtitle: '[Success] App was built'  })
    })

    return
  }

  if (['spa', 'pwa'].includes(argv.mode)) {
    warn('Built files are meant to be served over an HTTP server')
    warn(`Opening ${buildConfig.build.htmlFilename} over file:// won't work`)
    log()
  }

  finalize()
})
